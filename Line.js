// Generated by CoffeeScript 1.7.1
(function() {
  var Line, Utils;

  Utils = require('./Utils');


  /**
  * 曲线图
  * @param {Object} o.svgTagAttrs
  * @constructor
  *
   */

  Line = (function() {
    var LN10, bottomPadding, leftPadding, mathAvg, mathLog, mathMax, mathMin, mathPow, rightPadding, topPadding;

    topPadding = 15;

    bottomPadding = 20;

    leftPadding = 50;

    rightPadding = 15;

    function Line(o) {
      this.center = o.center || [100, 100];
      this.size = o.size || [400, 200];
      this.xAxis = o.xAxis || {};
      this.yAxis = o.yAxis || {};
      this.stepSize = o.stepSize;
      this.axisColor = o.axisColor || '#333';
      this.fontSize = o.fontSize || 12;
      this.xAxis.cols = this.xAxis.cols || [];
      (this.yAxis.lines = this.yAxis.lines || []).forEach(function(line) {
        line.values = line.values || [];
        line.color = line.color || '#63C1C3';
        return line.width = line.width || 2;
      });
      if (!this._requireData()) {
        return;
      }
      this.width = this.size[0] - leftPadding - rightPadding;
      this.height = this.size[1] - topPadding - bottomPadding;
      this.mergedLines = this._mergeLines();
      this.yMax = mathMax(this.mergedLines);
      this.yMin = mathMin(this.mergedLines);
      this.ySteps = Utils.getTicks(this.yMin, this.yMax, o.ticksCount || this.height / this.fontSize * 2);
      if (this.ySteps.length) {
        this.yStepMax = this.ySteps[this.ySteps.length - 1];
        this.yStepMin = this.ySteps[0];
        this.linesY = this._getLinesY();
      } else {
        this.yStepMax = this.yStepMin = 0;
        this.linesY = [];
      }
      this.xStepWidth = this.width / this.xAxis.cols.length;
      this.yValueHeight = this.height / this.ySteps[this.ySteps.length - 1];
    }

    Line.prototype._mergeLines = function() {
      var lines, mp, p, _i, _len;
      lines = this.yAxis.lines;
      if (lines.length === 0) {
        return [];
      }
      if (lines.length === 1) {
        return lines[0].values || [];
      }
      mp = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        p = lines[_i];
        mp = mp.concat(p.values || []);
      }
      return mp;
    };

    Line.prototype.toHTML = function() {
      if (!this._requireData()) {
        return '';
      }
      return ['<g>', this._axis('x'), this._axis('y'), this._path(), '</g>'].join('');
    };

    Line.prototype._getLinesY = function() {
      var line, lines, linesY, y, yValue, _i, _j, _len, _len1, _ref, _ref1;
      linesY = [];
      _ref = this.yAxis.lines;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        lines = _ref[_i];
        line = [];
        _ref1 = lines.values || [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          yValue = _ref1[_j];
          y = yValue * this.yValueHeight;
          line.push(y);
        }
        linesY.push(line);
      }
      return linesY;
    };

    Line.prototype._axis = function(type) {
      var axis, axisX, axisY, cols, fs, i, label, labels, p, step, stepMax, steps, width, xStepWidth, yFixNeg, yMin, _i, _j, _k, _len, _len1, _len2;
      cols = this.xAxis.cols;
      steps = this.ySteps;
      stepMax = steps[steps.length - 1];
      yMin = this.yMin;
      yFixNeg = Math.max(0, -yMin);
      xStepWidth = this.xStepWidth;
      width = this.width;
      fs = this.fontSize;
      labels = [];
      if (type === 'x') {
        axisX = xStepWidth * cols.length * 1.1;
        axisY = 0;
        for (i = _i = 0, _len = cols.length; _i < _len; i = ++_i) {
          p = cols[i];
          labels.push({
            x: (i + 1) * xStepWidth,
            y: -fs,
            text: p
          });
        }
      } else {
        axisX = 0;
        axisY = this._valueToY(stepMax + yFixNeg);
        for (_j = 0, _len1 = steps.length; _j < _len1; _j++) {
          step = steps[_j];
          labels.push({
            x: -5,
            y: this._valueToY(this._yValFallDown(step + yFixNeg)) - fs / 2,
            text: step
          });
        }
      }
      axis = '<g>';
      if (type === 'y') {
        axis += this._assistsY();
      }
      axis += "<line x1=\"" + (this._calcX(0)) + "\" y1=\"" + (this._calcY(0)) + "\" x2=\"" + (this._calcX(axisX)) + "\" y2=\"" + (this._calcY(axisY)) + "\" stroke=\"" + this.axisColor + "\" stroke-width=\"1\"></line>";
      for (i = _k = 0, _len2 = labels.length; _k < _len2; i = ++_k) {
        label = labels[i];
        axis += "<text x=\"" + (this._calcX(label.x)) + "\" y=\"" + (this._calcY(label.y)) + "\" fill=\"" + this.axisColor + "\" text-anchor=\"" + (type === 'x' ? 'middle' : 'end') + "\" font-size=\"12\">" + label.text + "</text>";
      }
      axis += '</g>';
      return axis;
    };

    Line.prototype._path = function() {
      var i, j, line, lineY, lines, linesY, pathD, paths, startX, startY, txt, val, x, xStepWidth, y, _i, _j, _len, _len1;
      lines = this.yAxis.lines;
      linesY = this.linesY;
      xStepWidth = this.xStepWidth;
      paths = '';
      for (i = _i = 0, _len = linesY.length; _i < _len; i = ++_i) {
        lineY = linesY[i];
        line = lines[i];
        startX = xStepWidth;
        startY = lineY[0] - this._valueToY(this.yStepMin);
        pathD = "M " + (this._calcX(startX)) + " " + (this._calcY(startY)) + " ";
        txt = '';
        for (j = _j = 0, _len1 = lineY.length; _j < _len1; j = ++_j) {
          y = lineY[j];
          x = xStepWidth * (j + 1);
          y = y - this._valueToY(this.yStepMin);
          pathD += 'L ' + this._calcX(x) + ' ' + this._calcY(y) + ' ';
          val = lines[i].values[j];
          if (typeof val !== 'undefined') {
            txt += ("<text x=\"" + (this._calcX(x)) + "\" y=\"" + (this._calcY(y - 5)) + "\" fill=\"#666\" font-size=\"12\" text-anchor=\"middle\">" + line.values[j] + "</text>") + ("<circle cx=\"" + (this._calcX(x)) + "\" cy=\"" + (this._calcY(y)) + "\" r=\"3\" fill=\"" + line.color + "\"></circle>");
          }
        }
        paths += "<g><path d=\"" + pathD + "\" stroke=\"" + line.color + "\" stroke-width=\"" + line.width + "\" fill=\"transparent\"></path>" + txt + "</g>";
      }
      return '<g>' + paths + '</g>';
    };

    Line.prototype._assistsY = function() {
      var asts, steps, width, yFixNeg, yMin;
      steps = this.ySteps;
      width = this.width;
      yMin = this.yMin;
      yFixNeg = Math.max(0, -yMin);
      asts = '';
      steps.forEach(function(step, i) {
        var y;
        step = steps[i];
        y = this._valueToY(this._yValFallDown(step + yFixNeg));
        return asts += "<line x1=\"" + (this._calcX(0)) + "\" y1=\"" + (this._calcY(y)) + "\" x2=\"" + (this._calcX(width)) + "\" y2=\"" + (this._calcY(y)) + "\" stroke=\"#CCC\" stroke-width=\"1\"></line>";
      });
      return asts;
    };

    Line.prototype._calcX = function(x) {
      return this.center[0] + x;
    };

    Line.prototype._calcY = function(y) {
      return this.center[1] - y;
    };

    Line.prototype._valueToY = function(val) {
      return val * this.yValueHeight;
    };

    Line.prototype._yValFallDown = function(val) {
      return val - this.yStepMin;
    };

    Line.prototype._yPXFallDown = function(y) {
      return y - this._valueToY(this.yStepMin);
    };

    Line.prototype._requireData = function() {
      if (!this.xAxis.cols.length) {
        return false;
      }
      return true;
    };

    Line.prototype.toString = function() {
      return this.toHTML();
    };

    mathPow = function(a, b) {
      return Math.pow(a, b);
    };

    mathLog = function(x) {
      return Math.log(x);
    };

    mathMax = function(arr) {
      return Math.max.apply(Math, arr);
    };

    mathMin = function(arr) {
      return Math.min.apply(Math, arr);
    };

    mathAvg = function(arr) {
      var a, v, _i, _len;
      v = 0;
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        a = arr[_i];
        v += a;
      }
      return v / arr.length;
    };

    LN10 = Math.LN10;

    return Line;

  })();

  if (typeof module !== 'undefined') {
    module.exports = Line;
  } else if (typeof define === 'function') {
    define(function(require, exports, module) {
      return module.exports = Line;
    });
  } else {
    window.Line = Line;
  }

}).call(this);
